// Generated by CoffeeScript 1.6.2
var Assert, BROWSER_OPTIONS, Browser, Console, Cookie, Cookies, Credentials, EventEmitter, EventLoop, File, HTML, HTML5, Interact, MOUSE_EVENT_NAMES, Mime, Path, Q, Resources, Storages, Tough, URL, XPath, assert, createTabs, format, ms,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

assert = require("assert");

Assert = require("./assert");

createTabs = require("./tabs");

Console = require("./console");

Cookies = require("./cookies");

EventEmitter = require("events").EventEmitter;

EventLoop = require("./eventloop");

format = require("util").format;

File = require("fs");

HTML5 = require("html5");

Interact = require("./interact");

HTML = require("jsdom").dom.level3.html;

Mime = require("mime");

ms = require("ms");

Q = require("q");

Path = require("path");

Resources = require("./resources");

Storages = require("./storage");

Tough = require("tough-cookie");

Cookie = Tough.Cookie;

URL = require("url");

XPath = require("jsdom").dom.level3.xpath;

require("./jsdom_patches");

require("./forms");

require("./dom_focus");

require("./dom_iframe");

BROWSER_OPTIONS = ["debug", "features", "headers", "htmlParser", "waitDuration", "proxy", "referer", "silent", "site", "userAgent", "maxRedirects", "language"];

MOUSE_EVENT_NAMES = ["mousedown", "mousemove", "mouseup"];

Browser = (function(_super) {
  __extends(Browser, _super);

  function Browser(options) {
    var browser, extension, name, _i, _j, _len, _len1, _ref;

    if (options == null) {
      options = {};
    }
    browser = this;
    this.cookies = new Cookies();
    this._storages = new Storages();
    this._interact = Interact.use(this);
    this._windowInScope = null;
    this.assert = new Assert(this);
    this.console = new Console(this);
    this.on("console", function(level, message) {
      if (!browser.silent) {
        switch (level) {
          case "error":
            return process.stderr.write(message + "\n");
          case "debug":
            if (browser.debug) {
              return process.stdout.write(message + "\n");
            }
            break;
          default:
            return process.stdout.write(message + "\n");
        }
      }
    });
    this.on("log", function(message) {
      if (browser.debug) {
        return process.stdout.write("Zombie: " + message + "\n");
      }
    });
    this.referer = null;
    this.resources = new Resources(this);
    this.on("request", function(request) {});
    this.on("response", function(request, response) {
      return browser.log("" + request.method + " " + request.url + " => " + response.statusCode);
    });
    this.on("redirect", function(request, response) {
      return browser.log("" + request.method + " " + request.url + " => " + response.statusCode + " " + response.url);
    });
    this.on("loaded", function(document) {
      return browser.log("Loaded document", document.location.href);
    });
    this.tabs = createTabs(this);
    this.on("opened", function(window) {
      return browser.log("Opened window", window.location.href, window.name || "");
    });
    this.on("closed", function(window) {
      return browser.log("Closed window", window.location.href, window.name || "");
    });
    this.on("active", function(window) {
      var element, onfocus;

      onfocus = window.document.createEvent("HTMLEvents");
      onfocus.initEvent("focus", false, false);
      window.dispatchEvent(onfocus);
      if (element = window.document.activeElement) {
        onfocus = window.document.createEvent("HTMLEvents");
        onfocus.initEvent("focus", false, false);
        return element.dispatchEvent(onfocus);
      }
    });
    this.on("inactive", function(window) {
      var element, onblur;

      if (element = window.document.activeElement) {
        onblur = window.document.createEvent("HTMLEvents");
        onblur.initEvent("blur", false, false);
        element.dispatchEvent(onblur);
      }
      onblur = window.document.createEvent("HTMLEvents");
      onblur.initEvent("blur", false, false);
      return window.dispatchEvent(onblur);
    });
    this.eventLoop = new EventLoop(this);
    this.errors = [];
    this.on("error", function(error) {
      browser.errors.push(error);
      return browser.console.error(error.message, error.stack);
    });
    this.on("done", function(timedOut) {
      if (timedOut) {
        return browser.log("Event loop timed out");
      } else {
        return browser.log("Event loop is empty");
      }
    });
    this.on("timeout", function(fn, delay) {
      return browser.log("Fired timeout after " + delay + "ms delay");
    });
    this.on("interval", function(fn, interval) {
      return browser.log("Fired interval every " + interval + "ms");
    });
    this.on("link", function(url, target) {
      return browser.log("Follow link to " + url);
    });
    this.on("submit", function(url, target) {
      return browser.log("Submit form to " + url);
    });
    for (_i = 0, _len = BROWSER_OPTIONS.length; _i < _len; _i++) {
      name = BROWSER_OPTIONS[_i];
      if (options.hasOwnProperty(name)) {
        this[name] = options[name];
      } else if (Browser["default"].hasOwnProperty(name)) {
        this[name] = Browser["default"][name];
      }
    }
    _ref = Browser._extensions;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      extension = _ref[_j];
      extension(this);
    }
  }

  Browser.extend = function(extension) {
    return Browser._extensions.push(extension);
  };

  Browser._extensions = [];

  Browser.prototype.hasFeature = function(name, ifMissing) {
    var features;

    if (ifMissing == null) {
      ifMissing = true;
    }
    if (this.features) {
      features = this.features.split(/\s+/);
      if (~features.indexOf(name)) {
        return true;
      }
      if (~features.indexOf("no-" + name)) {
        return false;
      }
    }
    return ifMissing;
  };

  Browser.prototype.withOptions = function(options, fn) {
    var k, restore, v, _ref,
      _this = this;

    if (options) {
      restore = {};
      for (k in options) {
        v = options[k];
        if (~BROWSER_OPTIONS.indexOf(k)) {
          _ref = [this[k], v], restore[k] = _ref[0], this[k] = _ref[1];
        }
      }
      return function() {
        var _results;

        _results = [];
        for (k in restore) {
          v = restore[k];
          _results.push(_this[k] = v);
        }
        return _results;
      };
    } else {
      return function() {};
    }
  };

  Browser.prototype.fork = function() {
    var forked, name, opt, _i, _len;

    opt = {};
    for (_i = 0, _len = BROWSER_OPTIONS.length; _i < _len; _i++) {
      name = BROWSER_OPTIONS[_i];
      opt[name] = this[name];
    }
    forked = Browser.create(opt);
    forked.loadCookies(this.saveCookies());
    forked.loadStorage(this.saveStorage());
    forked.location = this.location.url;
    return forked;
  };

  Browser.prototype.__defineGetter__("window", function() {
    return this.tabs.current;
  });

  Browser.prototype.open = function(options) {
    var name, referer, url;

    if (options) {
      url = options.url, name = options.name, referer = options.referer;
    }
    return this.tabs.open({
      url: url,
      name: name,
      referer: referer
    });
  };

  Browser.prototype.__defineGetter__("error", function() {
    return this.errors[this.errors.length - 1];
  });

  Browser.prototype.wait = function(options, callback) {
    var completionFunction, promise, waitDuration, _ref;

    if (!this.window) {
      process.nextTick(function() {
        return callback(new Error("No window open"));
      });
      return;
    }
    if (arguments.length === 1 && typeof options === "function") {
      _ref = [options, null], callback = _ref[0], options = _ref[1];
    }
    if (callback && typeof callback !== "function") {
      throw new Error("Second argument expected to be a callback function or null");
    }
    if (typeof options === "number") {
      waitDuration = options;
    } else if (typeof options === "string") {
      waitDuration = options;
    } else if (typeof options === "function") {
      waitDuration = this.waitDuration;
      completionFunction = options;
    } else if (options) {
      waitDuration = options.duration || this.waitDuration;
      if (options.element) {
        completionFunction = function(window) {
          return !!window.document.querySelector(options.element);
        };
      } else {
        completionFunction = options["function"];
      }
    } else {
      waitDuration = this.waitDuration;
    }
    promise = this.eventLoop.wait(waitDuration, completionFunction);
    if (callback) {
      promise.done(callback, callback);
    }
    return promise;
  };

  Browser.prototype.fire = function(selector, eventName, callback) {
    var event, eventType, target;

    if (!this.window) {
      throw new Error("No window open");
    }
    target = this.query(selector);
    if (!(target && target.dispatchEvent)) {
      throw new Error("No target element (note: call with selector/element, event name and callback)");
    }
    if (~MOUSE_EVENT_NAMES.indexOf(eventName)) {
      eventType = "MouseEvents";
    } else {
      eventType = "HTMLEvents";
    }
    event = this.document.createEvent(eventType);
    event.initEvent(eventName, true, true);
    target.dispatchEvent(event);
    return this.wait(callback);
  };

  Browser.prototype.click = function(selector, callback) {
    return this.fire(selector, "click", callback);
  };

  Browser.prototype.dispatchEvent = function(selector, event) {
    var target;

    target = this.query(selector);
    if (!this.window) {
      throw new Error("No window open");
    }
    return target.dispatchEvent(event);
  };

  Browser.prototype.queryAll = function(selector, context) {
    var elements;

    if (Array.isArray(selector)) {
      return selector;
    } else if (selector instanceof HTML.Element) {
      return [selector];
    } else if (selector) {
      context || (context = this.document);
      elements = context.querySelectorAll(selector);
      return Array.prototype.slice.call(elements, 0);
    } else {
      return [];
    }
  };

  Browser.prototype.query = function(selector, context) {
    if (selector instanceof HTML.Element) {
      return selector;
    }
    if (selector) {
      context || (context = this.document);
      return context.querySelector(selector);
    } else {
      return context;
    }
  };

  Browser.prototype.$$ = function(selector, context) {
    return this.query(selector, context);
  };

  Browser.prototype.querySelector = function(selector) {
    return this.document.querySelector(selector);
  };

  Browser.prototype.querySelectorAll = function(selector) {
    return this.document.querySelectorAll(selector);
  };

  Browser.prototype.text = function(selector, context) {
    if (this.document.documentElement) {
      return this.queryAll(selector || "html", context).map(function(e) {
        return e.textContent;
      }).join("").trim().replace(/\s+/g, " ");
    } else if (this.source) {
      return this.source.toString();
    } else {
      return "";
    }
  };

  Browser.prototype.html = function(selector, context) {
    if (this.document.documentElement) {
      return this.queryAll(selector || "html", context).map(function(e) {
        return e.outerHTML.trim();
      }).join("");
    } else if (this.source) {
      return this.source.toString();
    } else {
      return "";
    }
  };

  Browser.prototype.xpath = function(expression, context) {
    return this.document.evaluate(expression, context || this.document.documentElement, null, XPath.XPathResult.ANY_TYPE);
  };

  Browser.prototype.__defineGetter__("document", function() {
    if (this.window) {
      return this.window.document;
    }
  });

  Browser.prototype.__defineGetter__("body", function() {
    return this.document.querySelector("body");
  });

  Browser.prototype.__defineGetter__("activeElement", function() {
    return this.document.activeElement;
  });

  Browser.prototype.close = function(window) {
    return this.tabs.close.apply(this.tabs, arguments);
  };

  Browser.prototype.destroy = function() {
    if (this.tabs) {
      this.tabs.closeAll();
      return this.tabs = null;
    }
  };

  Browser.prototype.visit = function(url, options, callback) {
    var promise, resetOptions, site, _ref;

    if (typeof options === "function" && !callback) {
      _ref = [options, null], callback = _ref[0], options = _ref[1];
    }
    resetOptions = this.withOptions(options);
    if (site = this.site) {
      if (!/^(https?:|file:)/i.test(site)) {
        site = "http://" + site;
      }
      url = URL.resolve(site, URL.parse(URL.format(url)));
    }
    if (this.window) {
      this.tabs.close(this.window);
    }
    this.tabs.open({
      url: url,
      referer: this.referer
    });
    promise = this.wait(options);
    promise.then(resetOptions, resetOptions);
    if (callback) {
      promise.done(callback, callback);
    }
    return promise;
  };

  Browser.prototype.load = function(html, callback) {
    var deferred, error, first;

    this.location = "about:blank";
    try {
      this.errors = [];
      this.document.readyState = "loading";
      this.document.open();
      this.document.write(html);
      this.document.close();
    } catch (_error) {
      error = _error;
      this.emit("error", error);
    }
    first = this.errors[0];
    if (first) {
      if (callback) {
        process.nextTick(function() {
          return callback(first);
        });
      } else {
        deferred = Q.defer();
        deferred.reject(first);
        return deferred.promise;
      }
    } else {
      return this.wait(callback);
    }
  };

  Browser.prototype.__defineGetter__("location", function() {
    if (this.window) {
      return this.window.location;
    }
  });

  Browser.prototype.__defineSetter__("location", function(url) {
    if (this.window) {
      return this.window.location = url;
    } else {
      return this.open({
        url: url
      });
    }
  });

  Browser.prototype.__defineGetter__("url", function() {
    if (this.window) {
      return URL.format(this.window.location);
    }
  });

  Browser.prototype.link = function(selector) {
    var link, _i, _len, _ref;

    if (selector instanceof HTML.Element) {
      return selector;
    }
    link = this.querySelector(selector);
    if (link && link.tagName === "A") {
      return link;
    }
    _ref = this.querySelectorAll("body a");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      if (link.textContent.trim() === selector) {
        return link;
      }
    }
    return null;
  };

  Browser.prototype.clickLink = function(selector, callback) {
    var link;

    if (!(link = this.link(selector))) {
      throw new Error("No link matching '" + selector + "'");
    }
    return this.click(link, callback);
  };

  Browser.prototype.__defineGetter__("history", function() {
    if (!this.window) {
      this.open();
    }
    return this.window.history;
  });

  Browser.prototype.back = function(callback) {
    this.window.history.back();
    return this.wait(callback);
  };

  Browser.prototype.reload = function(callback) {
    this.window.location.reload();
    return this.wait(callback);
  };

  Browser.prototype.authenticate = function(host, create) {
    var credentials, _ref;

    if (create == null) {
      create = true;
    }
    host || (host = "*");
    credentials = (_ref = this._credentials) != null ? _ref[host] : void 0;
    if (!credentials) {
      if (create) {
        credentials = new Credentials();
        this._credentials || (this._credentials = {});
        this._credentials[host] = credentials;
      } else {
        credentials = this.authenticate();
      }
    }
    return credentials;
  };

  Browser.prototype.saveHistory = function() {
    return this.window.history.save();
  };

  Browser.prototype.loadHistory = function(serialized) {
    return this.window.history.load(serialized);
  };

  Browser.prototype.field = function(selector) {
    var error, field, forAttr, label, _i, _j, _len, _len1, _ref, _ref1;

    if (selector instanceof HTML.Element) {
      return selector;
    }
    try {
      field = this.query(selector);
      if (field && (field.tagName === "INPUT" || field.tagName === "TEXTAREA" || field.tagName === "SELECT")) {
        return field;
      }
    } catch (_error) {
      error = _error;
    }
    _ref = this.queryAll("input[name],textarea[name],select[name]");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      field = _ref[_i];
      if (field.getAttribute("name") === selector) {
        return field;
      }
    }
    _ref1 = this.queryAll("label");
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      label = _ref1[_j];
      if (label.textContent.trim() === selector) {
        if (forAttr = label.getAttribute("for")) {
          return this.document.getElementById(forAttr);
        } else {
          return label.querySelector("input,textarea,select");
        }
      }
    }
  };

  Browser.prototype.fill = function(selector, value) {
    var field, start_value;

    field = this.field(selector);
    if (!(field && (field.tagName === "TEXTAREA" || (field.tagName === "INPUT")))) {
      throw new Error("No INPUT matching '" + selector + "'");
    }
    if (field.getAttribute("disabled")) {
      throw new Error("This INPUT field is disabled");
    }
    if (field.getAttribute("readonly")) {
      throw new Error("This INPUT field is readonly");
    }
    field.focus();
    start_value = field.value;
    field.value = value;
    if (start_value !== value) {
      this.fire(field, "change");
      this.fire(field, "keydown");
      this.fire(field, "keyup");
      this.fire(field, "keypress");
    }
    return this;
  };

  Browser.prototype._setCheckbox = function(selector, value) {
    var field;

    field = this.field(selector);
    if (!(field && field.tagName === "INPUT" && field.type === "checkbox")) {
      throw new Error("No checkbox INPUT matching '" + selector + "'");
    }
    if (field.getAttribute("disabled")) {
      throw new Error("This INPUT field is disabled");
    }
    if (field.getAttribute("readonly")) {
      throw new Error("This INPUT field is readonly");
    }
    if (field.checked ^ value) {
      field.click();
    }
    return this;
  };

  Browser.prototype.check = function(selector) {
    return this._setCheckbox(selector, true);
  };

  Browser.prototype.uncheck = function(selector) {
    return this._setCheckbox(selector, false);
  };

  Browser.prototype.choose = function(selector) {
    var field;

    field = this.field(selector) || this.field("input[type=radio][value=\"" + (escape(selector)) + "\"]");
    if (!(field && field.tagName === "INPUT" && field.type === "radio")) {
      throw new Error("No radio INPUT matching '" + selector + "'");
    }
    field.click();
    return this;
  };

  Browser.prototype._findOption = function(selector, value) {
    var field, option, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;

    field = this.field(selector);
    if (!(field && field.tagName === "SELECT")) {
      throw new Error("No SELECT matching '" + selector + "'");
    }
    if (field.getAttribute("disabled")) {
      throw new Error("This SELECT field is disabled");
    }
    if (field.getAttribute("readonly")) {
      throw new Error("This SELECT field is readonly");
    }
    _ref = field.options;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      option = _ref[_i];
      if (option.value === value) {
        return option;
      }
    }
    _ref1 = field.options;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      option = _ref1[_j];
      if (option.label === value) {
        return option;
      }
    }
    _ref2 = field.options;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      option = _ref2[_k];
      if (option.textContent.trim() === value) {
        return option;
      }
    }
    throw new Error("No OPTION '" + value + "'");
  };

  Browser.prototype.select = function(selector, value) {
    var option;

    option = this._findOption(selector, value);
    this.selectOption(option);
    return this;
  };

  Browser.prototype.selectOption = function(selector) {
    var option, select;

    option = this.query(selector);
    if (option && !option.getAttribute("selected")) {
      select = this.xpath("./ancestor::select", option).iterateNext();
      option.setAttribute("selected", "selected");
      select.focus();
      this.fire(select, "change");
    }
    return this;
  };

  Browser.prototype.unselect = function(selector, value) {
    var option;

    option = this._findOption(selector, value);
    this.unselectOption(option);
    return this;
  };

  Browser.prototype.unselectOption = function(option) {
    var select;

    if (option && option.getAttribute("selected")) {
      select = this.xpath("./ancestor::select", option).iterateNext();
      if (!select.multiple) {
        throw new Error("Cannot unselect in single select");
      }
      option.removeAttribute("selected");
      select.focus();
      this.fire(select, "change");
    }
    return this;
  };

  Browser.prototype.attach = function(selector, filename) {
    var field, file, stat;

    field = this.field(selector);
    if (!(field && field.tagName === "INPUT" && field.type === "file")) {
      throw new Error("No file INPUT matching '" + selector + "'");
    }
    if (filename) {
      stat = File.statSync(filename);
      file = new this.window.File();
      file.name = Path.basename(filename);
      file.type = Mime.lookup(filename);
      file.size = stat.size;
      field.files || (field.files = []);
      field.files.push(file);
      field.value = filename;
    }
    field.focus();
    this.fire(field, "change");
    return this;
  };

  Browser.prototype.button = function(selector) {
    var button, input, inputs, _i, _j, _k, _len, _len1, _len2, _ref;

    if (selector instanceof HTML.Element) {
      return selector;
    }
    if (button = this.querySelector(selector)) {
      if (button.tagName === "BUTTON" || button.tagName === "INPUT") {
        return button;
      }
    }
    _ref = this.querySelectorAll("button");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      button = _ref[_i];
      if (button.textContent.trim() === selector) {
        return button;
      }
    }
    inputs = this.querySelectorAll("input[type=submit],button");
    for (_j = 0, _len1 = inputs.length; _j < _len1; _j++) {
      input = inputs[_j];
      if (input.name === selector) {
        return input;
      }
    }
    for (_k = 0, _len2 = inputs.length; _k < _len2; _k++) {
      input = inputs[_k];
      if (input.value === selector) {
        return input;
      }
    }
  };

  Browser.prototype.pressButton = function(selector, callback) {
    var button;

    if (!(button = this.button(selector))) {
      throw new Error("No BUTTON '" + selector + "'");
    }
    if (button.getAttribute("disabled")) {
      throw new Error("This button is disabled");
    }
    button.focus();
    this.fire(button, "click");
    return this.wait(callback);
  };

  Browser.prototype.getCookie = function(identifier, allProperties) {
    var cookie;

    identifier = this._cookieIdentifier(identifier);
    assert(identifier.name, "Missing cookie name");
    assert(identifier.domain, "No domain specified and no open page");
    cookie = this.cookies.select(identifier)[0];
    if (cookie) {
      if (allProperties) {
        return this._cookieProperties(cookie);
      } else {
        return cookie.value;
      }
    } else {
      return null;
    }
  };

  Browser.prototype.deleteCookie = function(identifier) {
    var cookie;

    identifier = this._cookieIdentifier(identifier);
    assert(identifier.name, "Missing cookie name");
    assert(identifier.domain, "No domain specified and no open page");
    cookie = this.cookies.select(identifier)[0];
    if (cookie) {
      this.cookies["delete"](cookie);
      return true;
    } else {
      return false;
    }
  };

  Browser.prototype.setCookie = function(nameOrOptions, value) {
    var domain, location;

    if (location = this.location) {
      domain = location.hostname;
    }
    if (typeof nameOrOptions === "string") {
      this.cookies.set({
        name: nameOrOptions,
        value: value || "",
        domain: domain,
        path: "/",
        secure: false,
        httpOnly: false
      });
    } else {
      assert(nameOrOptions.name, "Missing cookie name");
      this.cookies.set({
        name: nameOrOptions.name,
        value: nameOrOptions.value || value || "",
        domain: nameOrOptions.domain || domain,
        path: nameOrOptions.path || "/",
        secure: !!nameOrOptions.secure,
        httpOnly: !!nameOrOptions.httpOnly,
        expires: nameOrOptions.expires,
        "max-age": nameOrOptions["max-age"]
      });
    }
  };

  Browser.prototype.deleteCookies = function() {
    this.cookies.deleteAll();
  };

  Browser.prototype.saveCookies = function() {
    var cookie, serialized, _i, _len, _ref;

    serialized = ["# Saved on " + (new Date().toISOString())];
    _ref = this.cookies.sort(Tough.cookieCompare);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cookie = _ref[_i];
      serialized.push(cookie.toString());
    }
    return serialized.join("\n") + "\n";
  };

  Browser.prototype.loadCookies = function(serialized) {
    var line, _i, _len, _ref, _results;

    _ref = serialized.split(/\n+/);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      line = line.trim();
      if (line[0] === "#" || line === "") {
        continue;
      }
      _results.push(this.cookies.push(Cookie.parse(line)));
    }
    return _results;
  };

  Browser.prototype._cookieProperties = function(cookie) {
    var properties;

    properties = {
      name: cookie.key,
      value: cookie.value,
      domain: cookie.domain,
      path: cookie.path
    };
    if (cookie.secure) {
      properties.secure = true;
    }
    if (cookie.httpOnly) {
      properties.httpOnly = true;
    }
    if (cookie.expires && cookie.expires < Infinity) {
      properties.expires = cookie.expires;
    }
    return properties;
  };

  Browser.prototype._cookieIdentifier = function(identifier) {
    var domain, location, path;

    location = this.location;
    domain = location && location.hostname;
    path = location && location.pathname || "/";
    if (typeof identifier === "string") {
      identifier = {
        name: identifier,
        domain: domain,
        path: path
      };
    } else {
      identifier = {
        name: identifier.name,
        domain: identifier.domain || domain,
        path: identifier.path || path
      };
    }
    return identifier;
  };

  Browser.prototype.localStorage = function(host) {
    return this._storages.local(host);
  };

  Browser.prototype.sessionStorage = function(host) {
    return this._storages.session(host);
  };

  Browser.prototype.saveStorage = function() {
    return this._storages.save();
  };

  Browser.prototype.loadStorage = function(serialized) {
    return this._storages.load(serialized);
  };

  Browser.prototype.evaluate = function(code, filename) {
    if (!this.window) {
      this.open();
    }
    return this.window._evaluate(code, filename);
  };

  Browser.prototype.onalert = function(fn) {
    return this._interact.onalert(fn);
  };

  Browser.prototype.onconfirm = function(question, response) {
    return this._interact.onconfirm(question, response);
  };

  Browser.prototype.onprompt = function(message, response) {
    return this._interact.onprompt(message, response);
  };

  Browser.prototype.prompted = function(message) {
    return this._interact.prompted(message);
  };

  Browser.prototype.__defineGetter__("statusCode", function() {
    if (this.window && this.window._response) {
      return this.window._response.statusCode;
    } else {
      return null;
    }
  });

  Browser.prototype.__defineGetter__("success", function() {
    var statusCode;

    statusCode = this.statusCode;
    return statusCode >= 200 && statusCode < 400;
  });

  Browser.prototype.__defineGetter__("redirected", function() {
    return this.window && this.window._response && this.window._response.redirects > 0;
  });

  Browser.prototype.__defineGetter__("source", function() {
    if (this.window && this.window._response) {
      return this.window._response.body;
    } else {
      return null;
    }
  });

  Browser.prototype.viewInBrowser = function(browser) {
    return require("./bcat").bcat(this.html());
  };

  Browser.prototype.log = function() {
    var args;

    if (typeof arguments[0] === "function") {
      args = [arguments[0]()];
    } else {
      args = arguments;
    }
    return this.emit("log", format.apply(null, args));
  };

  Browser.prototype.dump = function() {
    var html, indent;

    indent = function(lines) {
      return lines.map(function(l) {
        return "  " + l + "\n";
      }).join("");
    };
    process.stdout.write("Zombie: " + Browser.VERSION + "\n\n");
    process.stdout.write("URL: " + this.window.location.href + "\n");
    process.stdout.write("History:\n" + (indent(this.window.history.dump())) + "\n");
    process.stdout.write("Cookies:\n" + (indent(this.cookies.dump())) + "\n");
    process.stdout.write("Storage:\n" + (indent(this._storages.dump())) + "\n");
    process.stdout.write("Eventloop:\n" + (indent(this.eventLoop.dump())) + "\n");
    if (this.document) {
      html = this.document.outerHTML;
      if (html.length > 497) {
        html = html.slice(0, 497) + "...";
      }
      return process.stdout.write("Document:\n" + (indent(html.split("\n"))) + "\n");
    } else {
      if (!this.document) {
        return process.stdout.write("No document\n");
      }
    }
  };

  return Browser;

})(EventEmitter);

Browser.VERSION = JSON.parse(File.readFileSync("" + __dirname + "/../../package.json")).version;

Browser["default"] = {
  debug: false,
  features: "scripts no-css",
  htmlParser: HTML5,
  maxRedirects: 5,
  proxy: null,
  silent: false,
  site: void 0,
  userAgent: "Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/" + Browser.VERSION,
  language: "en-US",
  waitDuration: "5s"
};

Browser.create = function(options) {
  return new Browser(options);
};

Credentials = (function() {
  function Credentials() {}

  Credentials.prototype.apply = function(headers) {
    var base64;

    switch (this.scheme) {
      case "basic":
        base64 = new Buffer(this.user + ":" + this.password).toString("base64");
        return headers["authorization"] = "Basic " + base64;
      case "bearer":
        return headers["authorization"] = "Bearer " + this.token;
      case "oauth":
        return headers["authorization"] = "OAuth " + this.token;
    }
  };

  Credentials.prototype.basic = function(user, password) {
    this.user = user;
    this.password = password;
    return this.scheme = "basic";
  };

  Credentials.prototype.bearer = function(token) {
    this.token = token;
    return this.scheme = "bearer";
  };

  Credentials.prototype.oauth = function(token) {
    this.token = token;
    return this.scheme = "oauth";
  };

  Credentials.prototype.reset = function() {
    delete this.scheme;
    delete this.token;
    delete this.user;
    return delete this.password;
  };

  return Credentials;

})();

module.exports = Browser;
